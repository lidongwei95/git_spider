python 处理 RSA加密、解密、签名、验签

一、环境配置
ubuntu16.04
使用python3.5.2

安装环境依赖
## pipreqs . --encoding=utf8 --force // 在项目下打包环境依赖到requirement.txt
python3 -m pip install -r requirements.txt

1、先使用 wzf_rsa.py 生成公钥私钥
2、使用 en_de_crypto.py 调用接口，获取参数，并使用其中的方法实现相应需求

RSA非对称加解密

1.1RSA非对称加密解密

1.1.1前期准备

1．平台分配内容：渠道id，key（客户端请注意保密），平台公钥（格式：编码为BASE64字符串）

2．RSA秘钥对生成设置：

(1)加密算法：KEY_ALGORITHM = "RSA"

(2)秘钥长度：2048 

3．调用方生成秘钥对后，需要将二进制公钥数据编码为BASE64字符串并告知平台

1.1.2签名算法说明

1.1.2.1签名场景

简单描述使用非对称RSA生成数字签名以及验证签名的场景。非对称加密签名场景，通常包含以下步骤：

1．调用方将验签公钥分发给短链接平台。

2．调用方使用签名私钥，对数据产生签名。

3．调用方将数据以及签名传递给短链接平台。

4．短链接平台获得数据和签名后，使用调用方公钥针对数据验证签名的合法性。

1.1.2.2签名规则

1．签名使用的源数据由平台分配给客户端的 key值、访问渠道编号sysId及时间戳timestamp组成，其组合顺序为key+sysId+timestamp。

2．对上述源数据使用私钥进行加签，加签规则如下：

(1)使用调用方私钥对明文签名加签，签名算法为MD5withRSA

(2)将加密后的byte数组转为十六进制的string字符串（英文字母全大写）。

3．加签后的数据便是对应用户的数字签名

用户key示例：u2gmpd0e96s34h45

用户签名sign加签前示例：u2gmpd0e96s34h452000120201129231502123

用户签名sign加签后示例：66720CEECC95EBDE3BC8407DA05B3377686764434CDA487DD0830B45C3F2EE965913EDAD466F48C769DA0CEA5113963CF374126E9592927D23FA107F0DAF36BABE01F072D17348A2B0B9D88874DA20D66A3B3C6F9724FAEFEE2FC4C2295D02A0140BD7D4DF740AAF820B07D00A8A069AC40E141704621BDC127773D050E5EEEECC68F8EDCBDD9BC3FA587C09CECC7606154E98977EDCE54510BAB4C15074EA38F77035412500B9249B7EF636A8134CA173FE8D6C038538B74388BBB39E72594F9E62918E86E5646F42C97A22768B638A467DD1EA2D0EE00AC36EFC1AF45132

备注： key业务上线时再颁发（客户端请注意保密key值）。

1.1.3加解密规则说明

1.1.3.1加解密场景

本文简单描述了使用非对称RSA进行数据加密和解密的场景。非对称加密场景，通常包含以下步骤：

1．信息接收者将加密公钥分发给信息传送者。

2．信息传送者使用公钥对敏感信息进行加密保护。

3．信息传送者将敏感信息的密文传递给信息接收者。

4．信息接收者使用私钥将敏感信息的密文解密。

1.1.3.2加解密规则

1.1.3.2.1加密规则

本规则适用于调用方发起请求的参数加密流程：

1．调用方将结果参数（包含sign）先拼接成一个json串，然后使用平台公钥（由平台颁发）对该json串进行加密，加密过程如下：

(1)BASE64对公钥进行解码，然后使用X509对解码后的公钥进行加密获得原始公钥。

(2)使用公钥对明文数据进行加密。

(3)将加密后的byte数组转为十六进制的string字符串（英文字母全大写）。

2．将加密后的信息赋值到String类型的parameter变量中进行传递；

1.1.3.2.2解密规则

本规则适用于调用方接收到返回参数的解密流程：

1．调用方接收到key为resultJson，value是密文的数据。

2．将十六进制的密文字符串转化为byte数组。

3．对转化后的数据使用调用方自己的私钥进行解密。

4．将解密后的数据转为string类型，获得明文数据。
